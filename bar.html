<!DOCTYPE html>
<meta charset="utf-8">

<!-- Load d3.js -->
<script src="https://tools-static.wmflabs.org/cdnjs/ajax/libs/uuid/8.3.0/uuidv4.min.js"></script>
<script src="https://tools-static.wmflabs.org/cdnjs/ajax/libs/d3/4.13.0/d3.min.js"></script>
<script src="https://d3js.org/d3-scale-chromatic.v1.min.js"></script>
<!--<script src="https://code.jquery.com/jquery-1.7.2.min.js"></script>-->


<style>
 div {
     max-width: 1480px;
 }
 
 div.tooltip {	
     position: absolute;			
     text-align: left;			
     /*width: 60px;					
        height: 28px;*/					
     padding: 2px;				
     font: 12px sans-serif;		
     background: white;	
     border: 0px;		
     border-radius: 8px;			
     pointer-events: none;			
 }

 .x .tick {
     visibility:hidden;
 }

 label {
     font: 12px sans-serif;
     font-weight: 700;
 }

 div#controls {
     text-align: right;
 }
 
</style>

<!-- Create a div where the graph will take place -->
<div id="treemap-container"></div>
<div id="controls">
    <select name="highlighting" id="highlighting">
        <option value="under">High Views : Low Quality</option>
        <option value="over">Low Views : High Quality</option>
        <option value="all">All Misalignment</option>
    </select>
</div>
<div id="bar-container"></div>

<script>
 var colorPalette2 = [
     "#E8DCBE",
     "#D9DFDB",
     "#3C7244",
     "#E4CCBD",
     "#D8B29C",
     "#DCA1AF",
     "#606264",
     "#416D93",
     "#7DA459",
     "#903D45",
     "#75473E",
     "#7BA4CA",
     "#919392",
     "#6A99AD",
     "#ABC27B",
     "#A6A6A3",
     "#8AB4BC",
     "#C7D297",
     "#D4B2A6",
     "#B6A392",
     "#B4A134",
     "#DDC299",
     "#BCBAB6",
     "#A9C3C1",
     "#8D4E40",
     "#428E70",
     "#5169AE",
     "#C6D6CE",
     "#D36B3E",
     "#8F8B7F",
     "#91AAC9",
     "#D98C64",
     "#ABBDC9",
     "#92AEA1",
     "#EBD3B8",
     "#B0473B",
     "#BDC8B8",
     "#B67B62",
     "#E9E4D8",
     "#DAB07B",
     "#F1BA1B"
 ];

 var metrics = {
     "misalignment":"Misalignment",
     "weighted_sum":"Quality",
     "num_unique_registered_users":"Editors",
     "monthly_pageviews":"Views",
     //"num_revisions":"Revisions",
 };
 
 var width = 1500;
 var height = 1000;
 
 var metricLineSpace = 12;
 var textLineSpace = 16;
 var headerLineSpace = 16;
 var headerHeight = (headerLineSpace * 2) + (headerLineSpace * .5); 
 var textStyle = "sans-serif";
 var format = d3.format(",d");
 //var color = d3.scaleOrdinal(d3.schemeCategory10)
 var layout = "treemapSquarify";
 var datapath = "edcast_taxo_metrics_04-30-21.json";//"joined_metrics_1-5-21.json";
 var padding = 1;

 // set the dimensions and margins of the graph
 var margin = {top: 10, right: 10, bottom: 10, left: 10},
     width = width - margin.left - margin.right,
     height = height - margin.top - margin.bottom;

 const urlParams = new URLSearchParams(window.location.search);

 function color(range) {
     return d3.scaleSequential(d3['interpolateGreys']).domain(range);
 }
 
 function tile(node, x0, y0, x1, y1) {
     d3.treemapBinary(node, 0, 0, width, height);
     for (const child of node.children) {
         child.x0 = x0 + child.x0 / width * (x1 - x0);
         child.x1 = x0 + child.x1 / width * (x1 - x0);
         child.y0 = y0 + child.y0 / height * (y1 - y0);
         child.y1 = y0 + child.y1 / height * (y1 - y0);
     }
 }

 function resizeText() {
     const newWidth = d3.select("svg").style("width");
     const newHeaderHeight = headerLineSpace * (width / parseInt(newWidth));
     const newTextHeight = textLineSpace * (width / parseInt(newWidth));
     const newMetricHeight = metricLineSpace * (width / parseInt(newWidth));
     
     d3.selectAll("text.header")
       .attr("style", `font: ${newHeaderHeight}px ${textStyle}`);
     d3.selectAll("tspan.header.name")
       .attr("x", function(d){ return d.x0+5})    // +10 to adjust position (more right)
       .attr("y", function(d){ return d.y0+newHeaderHeight});    // +20 to adjust position (lower)
     d3.selectAll("tspan.header.value")
       .attr("x", function(d){ return d.x0+5})    // +10 to adjust position (more right)
       .attr("y", function(d){ return d.y0+(newHeaderHeight*2)});    // +20 to adjust position (lower)

     d3.selectAll("text.body")
       .attr("style", `font: ${newTextHeight}px ${textStyle}`);
     d3.selectAll("tspan.body.name")
       .attr("x", function(d){ return d.x0+5;})    // +10 to adjust position (more right)
       .attr("y", function(d){ return d.y0+(newTextHeight * d3.select(this).attr("line-number"))});    // +20 to adjust position (lower)
     d3.selectAll("tspan.body.value")
       .attr("x", function(d){ return d.x0+5})    // +10 to adjust position (more right)
       .attr("y", function(d){ return d.y0+(newTextHeight * d3.select(this).attr("line-number"))});    // +20 to adjust position (lower)

 }

 function getRootText(root) {
     crumb = "";
     do {
         crumb = `${root.data.name} : ${crumb}`;
         root = root.parent ? root.parent : null;
     } while (root);
     return crumb;
 }

 function wrapText(d) {
     d.append("tspan")
      .text(d.data.name);
     d.each(function (d) {
         
     });
 }

 function strokeColor(d, root, highlightingDict) {
     if (d === root) {
         return "none";
     } else if (d.data.misalignment > d.parent.data.misalignment_std && highlightingDict["over"] == true) {
         return "black";
     } else if (d.data.misalignment <  (-d.parent.data.misalignment_std) && highlightingDict["under"] == true) {
         return "black";
     } else if (d.data.weighted_sum >= 4 && Math.abs(d.data.misalignment) < d.parent.data.misalignment_std) {
         return "none";
     } else {
         return "none";
     }
 }

 function opacityHighlighting(d, root, highlightingDict) {
     if (d === root) {
         return .6;
     } else if (d.data.misalignment > d.parent.data.misalignment_std && highlightingDict["over"] == true) {
         return 1;
     } else if (d.data.misalignment <  (-d.parent.data.misalignment_std) && highlightingDict["under"] == true) {
         return 1;
     } else if (d.data.weighted_sum >= 4 && Math.abs(d.data.misalignment) < d.parent.data.misalignment_std) {
         return .6;
     } else {
         return .6;
     }
 }

 d3.select(window).on("resize", resizeText);

 var toolTip = d3.select("body").append("div")	
                 .attr("class", "tooltip")				
                 .style("opacity", 0);

 function getChildren(root, depth) {
     children = root.children;
     for (i=0; i < depth; i++) {
         children = children.map(x => x.children).flat().filter(x => x !== undefined);
     }
     return children;
 }

 function getParent(node, height) {
     for (i=0; i < height; i++) {
         node = node.parent;
     }
     return node
 }

 // read json data
 d3.json(datapath, function(data) {

     var highlightingDict = {
         "over":false,
         "under":true
     };

     var highlightingStyle = "stroke";

     var highlightingSelector = document.querySelector("select#highlighting");
     highlightingSelector.addEventListener("change", updateHighlighting);

     function updateHighlighting(e) {
         if (e.target.value == "over") {
             highlightingDict["over"] = true;
             highlightingDict["under"] = false;
         } else if (e.target.value == "under") {
             highlightingDict["over"] = false;
             highlightingDict["under"] = true;
         } else {
             highlightingDict["over"] = true;
             highlightingDict["under"] = true;
         };

         d3.selectAll("line.highlighting")
           .attr("stroke", d => strokeColor(d,root,highlightingDict))

         d3.selectAll("rect.treemap")
           .attr("stroke", d => strokeColor(d,root,highlightingDict))
           .attr("fill-opacity", d => opacityHighlighting(d,root,highlightingDict));

         d3.selectAll("rect.bar")
           .attr("fill-opacity", d => opacityHighlighting(d,root,highlightingDict));
     }

     // Give the data to this cluster layout:
     var root = d3.hierarchy(data)
                  .sum(d => d.value)
                  .sort((a, b) => b.data.misalignment - a.data.misalignment); // Here the size of each leave is given in the 'value' field in input data
     // append the svg object to the body of the page
     var treemapSVG = d3.select("#treemap-container")
                 .append("svg")
                 .attr("viewBox", [-margin.left, -headerHeight*1.5 -margin.top, width + margin.right + margin.left, height/2 + headerHeight*1.5 + margin.top + margin.bottom])
                 .attr("style", `max-width: ${width}px`);

     var color = d3.scaleOrdinal().domain(root.children).range(colorPalette2);
     var x = d3.scaleLinear().rangeRound([0, width]);
     var y = d3.scaleLinear().rangeRound([0, height/2]);

     var treemapLayout = d3.treemap()
                           .tile(tile);                  

     treemapLayout(root);

     var group = treemapSVG.append("g")
                           .attr("id", "canvas-treeMap");

     
                           //.attr("transform", "translate(0," + margin.top + ")");

     
     render(group, root);

     var barHeight = ((height/2)/Object.keys(metrics).length);
     for (var metric in metrics) {
         //if (metric != "misalignment") {
             /*var barContainer = d3.select("#bar-container")
                                  .append("div")
                                  .attr("class",`bar-container`)
                                    .attr("id",`${metric}`);
         */

         var barSVG = d3.select("#bar-container")
                        .append("svg")
                        .attr("class","bar-svg")
                        .attr("id",`${metric}`)
                        .attr("viewBox", [-margin.left, -margin.top, width + margin.right + margin.left, barHeight + margin.top + margin.bottom + headerLineSpace])
                        .attr("style", `max-width: ${width}px; display: block;`);

         var barCanvas = barSVG.append("g")
                               .attr("class","bar-canvas")
                               .attr("id",`${metric}`);
         //}

     };

     d3.selectAll("g.bar-canvas")
       .call(renderBarGraph, root, barHeight);

     function renderBarGraph(canvas_list, root, height) {
         var depth = 1
         var children = getChildren(root,depth) //root.children.map(x => x.children).flat().filter(x => x !== undefined);
         for (var element of canvas_list.nodes()) {
             metric = element.id;
             canvas = d3.select(element);
             //var children = root.leaves();

             var x_bar = d3.scaleBand()
                           .domain(children.map(function(d) { return d.data.name; }))
                           .range([margin.left+50, width])
                           .padding(0.1);

             if (metric == 'misalignment') {
                 var y_bar = d3.scaleLinear()
                               .domain([d3.min(children, d => d.data[metric]), d3.max(children, d => d.data[metric])]).nice()
                               .range([(height - margin.top - margin.bottom), 0]);
             } else if (metric == 'weighted_sum') {
                 var y_bar = d3.scaleLinear()
                               .domain([0, 6]).nice()
                               .range([(height - margin.top - margin.bottom), 0]);

             } else {
                 var y_bar = d3.scaleLinear()
                               .domain([0, d3.max(children, d => d.data[metric])]).nice()
                               .range([(height - margin.top - margin.bottom), 0]);
             }

             var xAxis = d3.axisBottom(x_bar);

             var yAxis = d3.axisLeft(y_bar)
                           .ticks(5);

             /*canvas.append("g")
                   .attr("class", "x axis")
                   .attr("transform", "translate(0," + (height - margin.bottom + (headerLineSpace*1.5)) + ")")
                   .call(xAxis);
             */
             
             canvas.append("g")
                   .attr("class", "y axis")
                   .attr("transform", `translate(50,${headerLineSpace*1.5})`)
                   .style("font", `${headerLineSpace}px ${textStyle}`)
                     .call(yAxis);

             var bars = canvas.selectAll("bar")
                              .data(children)
                              .enter().append("rect")
                              .attr("class", "bar")
                              .attr("id", d => d.uid)
                              .attr("x", function(d) { return x_bar(d.data.name); })
                              .attr("width", x_bar.bandwidth())
                              .attr("y", d => d.data[metric] >= 0 ? y_bar(d.data[metric]) + (headerLineSpace*1.5) : y_bar(0) + (headerLineSpace*1.5))
                              .attr("height",  d => Math.abs(y_bar(0) - y_bar(d.data[metric])))
                              .attr("fill", d => (color(getParent(d,depth).data.name)))
                              .attr("fill-opacity", d => opacityHighlighting(d,root,highlightingDict));
                              //.attr("stroke", d => strokeColor(d,root,highlightingDict));

             var upperLine = canvas.selectAll("bar")
                                   .data(children)
                                   .enter()
                                   //.filter(d => d.data.misalignment > d.parent.data.misalignment_std)
                                   .append("line")
                                   .attr("class","highlighting")
                                   .attr("opacity",".6")
                                   .attr("stroke-width","0.3")
                                   .attr("stroke", d => strokeColor(d,root, highlightingDict))
                                   .attr("x1", d => x_bar(d.data.name) + x_bar.bandwidth()/2)
                                   .attr("x2", d => x_bar(d.data.name) + x_bar.bandwidth()/2)
                                   .attr("y1", _ => canvas_list.nodes().indexOf(element) == 0 ? headerLineSpace*1.5 : 0 - margin.top)
                                   .attr("y2", d => d.data[metric] >= 0 ? y_bar(d.data[metric]) + (headerLineSpace*1.5) : y_bar(0) + headerLineSpace*1.5);

             var lowerLine = canvas.selectAll("bar")
                                   .data(children)
                                   .enter()
                                   //.filter(d => d.data.misalignment > d.parent.data.misalignment_std)
                                   .append("line")
                                   .attr("class","highlighting")
                                   .attr("opacity",".6")
                                   .attr("stroke-width","0.3")
                                   .attr("stroke", d => strokeColor(d, root, highlightingDict))
                                   .attr("x1", d => x_bar(d.data.name) + x_bar.bandwidth()/2)
                                   .attr("x2", d => x_bar(d.data.name) + x_bar.bandwidth()/2)
                                   .attr("y1", d => d.data[metric] <= 0 ? y_bar(d.data[metric]) + (headerLineSpace*1.5) : y_bar(0) + headerLineSpace*1.5)
                                   .attr("y2", d => canvas_list.nodes().indexOf(element) != canvas_list.nodes().length - 1 ? height + margin.top + margin.bottom + (headerLineSpace*1.5) : d.data[metric] < 0 ? height : y_bar(0) + headerLineSpace*1.5);

             bars.filter(d => d === root ? d.parent : d.children)
                 .attr("cursor", "pointer")
                 .on("click", d => d === root ? zoomout(root) : zoomin(d.parent));

             canvas.append("text")
                   .attr("class", "bar-title")
                   .attr("style",  `font: ${headerLineSpace}px ${textStyle}; font-weight: 700; text-anchor: left`)
                   .attr("x", 0)             
                   .attr("y", (margin.top))
                   .text(`${metrics[metric]}`);

             bars.on("mouseover", function(d) {
                 if (d != root) {
	             toolTip.transition()		
                            .duration(200)		
                            .style("opacity", .9);
                     
                     toolTipText = `${d.data.name}`;
                     toolTipText += d.data.children ? `<br/>Number of Articles: ${d.value}`: '';
                     for (metric in metrics) {
                         toolTipText += `<br/>${metrics[metric]}: ${d.data[metric].toFixed(2)}`;
                     };
                     toolTip.html(toolTipText)
                            .style("left", (d3.event.pageX) + "px")		
                            .style("top", (d3.event.pageY - 28) + "px");
                 }
             });

             bars.on("mouseout", function(d) {		
                 toolTip.transition()		
                        .duration(500)		
                        .style("opacity", 0);
	     });
         }
     }

     function render(group, root) {
         
         // Then d3.treemap computes the position of each element of the hierarchy
         
         //var color = d3.scaleOrdinal().domain(data).range(colorPalette2);

         // use this information to add rectangles:
         var nodes = group.selectAll("g#canvas-treeMap")
                          .data(root.children.concat(root))
                          .enter()
                          .append("g")
                          .attr("class","node");

         nodes.filter(d => d === root ? d.parent : d.children)
              .attr("cursor", "pointer")
              .on("click", d => d === root ? zoomout(root) : zoomin(d));

         //var range = d3.extent(nodes.data(), d => d === root ? null : d.children ? d.data.mean_quality : d.data.quality_weighted_sum);
         
         nodes.append("rect")
              .attr("class","treemap")
              .attr('x', function (d) { return d.x0; })
              .attr('y', function (d) { return d.y0; })
              .attr('width', function (d) { return d.x1 - d.x0; })
              .attr('height', function (d) { return d.y1 - d.y0; })
              .attr("fill", d => d === root ? "#fff" : d.children ? color(d.data.name) : "#ccc")
              .attr("stroke", d => strokeColor(d, root, highlightingDict))
              .attr("fill-opacity", d => opacityHighlighting(d, root, highlightingDict))
              .attr("id", d => (d.uid = uuidv4()));

         nodes.append("clipPath")
              .attr("id", d => (`clip-${d.uid}`))
              .append("use")
              .attr("xlink:href", d => `#${d.uid}`);

         getRootText(root);

         nodes.append("text")
              .attr("class", d => d === root ? "header" : "body")
              .attr("style",  `font: ${textLineSpace}px ${textStyle}`)
              .attr("clip-path", d => (`url(#clip-${d.uid})`));

         var headerText = d3.selectAll("text.header");
         var nodeText = d3.selectAll("text.body");

         headerText.append("tspan")
                   .text(d => getRootText(d))
                   .attr("font-weight", "700")
                   .attr("class", "header name")
                   .attr("x", d => d.x0+5)    
                   .attr("y", d => d.y0+headerLineSpace);

         headerText.append("tspan")
                   .text(d => `Number of Articles: ${d.value}; Mean Misalignment: ${d.data.misalignment.toFixed(2)}; STD of Misalignment: ${d.data.misalignment_std.toFixed(2)}`)
                   .attr("class", "header value")
                   .attr("style",  `font: ${metricLineSpace}px ${textStyle}`)
                   .attr("x", d => d.x0+5)    // +10 to adjust position (more right)
                   .attr("y", d => d.y0+(headerLineSpace*2))
                   .attr("fill-opacity",0.7);    // +20 to adjust position (lower)
                  
         nodeText.each(wrap);
         
         function wrap(d) {
             
             text = d3.select(this);
             words = d.data.name.split(" ").reverse();
             lineNumber = 1;
             while (word = words.pop()) {
                 span = text.append("tspan")
                            .text(word)
                            .attr("font-weight", "700")
                            .attr("class", "body name")
                            .attr("x", d => d.x0+5)    // +10 to adjust position (more right)
                            .attr("y", d => d.y0+(textLineSpace*lineNumber))
                            .attr("line-number",lineNumber);
                 lineNumber += 1;
             };
             
             text.append("tspan")
                 .text(d => d.children ? `Number of Articles: ${d.value}` : '')
                 .attr("class", d => d === root ? "header value" : "body value")
                 .attr("x", function(d){ return d.x0+5})    // +10 to adjust position (more right)
                 .attr("y", d => d === root ? d.y0+(headerLineSpace*2) : d.y0+(textLineSpace*lineNumber))
                 .attr("style",  `font: ${metricLineSpace}px ${textStyle}`)
                 .attr("fill-opacity",0.7)
                 .attr("line-number",lineNumber);// +20 to adjust position (lower)

             for (var metric in metrics) {
                 text.append("tspan")
                     .text(d => `${metrics[metric]}: ${d.data[metric].toFixed(2)}`)
                     .attr("class", d => d === root ? "header value" : "body value")
                     .attr("x", function(d){ return d.x0+5})    // +10 to adjust position (more right)
                     .attr("y", d => d === root ? d.y0+(headerLineSpace*2) : d.y0+(textLineSpace*lineNumber))
                     .attr("style",  `font: ${metricLineSpace}px ${textStyle}`)
                     .attr("fill-opacity",0.7)
                     .attr("line-number",d => d.children ? lineNumber+1 : lineNumber);    // +20 to adjust position (lower)
                 lineNumber += 1;
                 }
         }
         

         resizeText();
         
         group.call(position, root);

         nodeText.on("mouseover", function(d) {
             if (d != root) {
	         toolTip.transition()		
                        .duration(200)		
                        .style("opacity", .9);
              
                 toolTipText = `${d.data.name}`;
                 toolTipText += d.data.children ? `<br/>Number of Articles: ${d.value}`: '';
                 for (metric in metrics) {
                     toolTipText += `<br/>${metrics[metric]}: ${d.data[metric].toFixed(2)}`;
                 };
                 toolTip.html(toolTipText)
                        .style("left", (d3.event.pageX) + "px")		
                        .style("top", (d3.event.pageY - 28) + "px");
             }
         });

         nodeText.on("mouseout", function(d) {		
             toolTip.transition()		
                    .duration(500)		
                    .style("opacity", 0);
	 });
     };

     function setMetric(nodeList) {
         for (var node of nodeList.nodes()) {
             metric = node.parentNode.id;
             d3.select(node).attr("id", metric);
         }
     }

     function zoomin(d) {
         root = d;
         var group0 = group.attr("pointer-events", "none");
         var group1 = group = treemapSVG.append("g").attr("id","canvas-treeMap").call(render, root);

         var barCanvas0 = d3.selectAll("g.bar-canvas").attr("pointer-events", "none");
         var barCanvas1 = d3.selectAll("svg.bar-svg")
                            .append("g")
                            .attr("class","bar-canvas")
                            .call(setMetric);

         d3.select("svg.bar-svg")
           .transition()
           .duration(750)
           .call(t => barCanvas0.transition(t).attrTween("opacity", () => d3.interpolate(1, 0)).remove())
           .call(t => barCanvas1.call(renderBarGraph, d, barHeight).transition(t).attrTween("opacity", () => d3.interpolate(0, 1)));
         
         
         //var barCanvas1 = barCanvas = SVG.append("g").attr("id","canvas-treeMap").call(render, d);

         x.domain([d.x0, d.x1]);
         y.domain([d.y0, d.y1]);

         treemapSVG.transition()
                   .duration(750)
                   .call(t => group0.transition(t).attrTween("opacity", () => d3.interpolate(1, 0)).remove()
                                    .call(position, d.parent))
                   .call(t => group1.transition(t)
                                    .attrTween("opacity", () => d3.interpolate(0, 1))
                                    .call(position, d));
     }

     function zoomout(d) {
         root = d.parent;
         const group0 = group.attr("pointer-events", "none");
         const group1 = group = treemapSVG.insert("g", "*").attr("id","canvas-treeMap").call(render, root);

         var barCanvas0 = d3.selectAll("g.bar-canvas").attr("pointer-events", "none");
         var barCanvas1 = d3.selectAll("svg.bar-svg")
                            .append("g")
                            .attr("class","bar-canvas")
                            .call(setMetric);

         d3.select("svg.bar-svg")
           .transition()
           .duration(750)
           .call(t => barCanvas0.transition(t).attrTween("opacity", () => d3.interpolate(1, 0)).remove())
           .call(t => barCanvas1.call(renderBarGraph, d.parent, barHeight).transition(t).attrTween("opacity", () => d3.interpolate(0, 1)));
         

         x.domain([d.parent.x0, d.parent.x1]);
         y.domain([d.parent.y0, d.parent.y1]);

         treemapSVG.transition()
            .duration(750)
            .call(t => group0.transition(t).remove()
                             .attrTween("opacity", () => d3.interpolate(1, 0))
                             .call(position, d))
            .call(t => group1.transition(t)
                             .call(position, d.parent));
     }

     function position(group, root) {
         group.selectAll("g.node")
              .attr("transform", d => d === root ? `translate(0,${-headerHeight*1.5})` : `translate(${x(d.x0)},${y(d.y0)})`)
              .select("rect")
              .attr("width", d => d === root ? width : x(d.x1) - x(d.x0))
              .attr("height", d => d === root ? headerHeight*1.5: y(d.y1) - y(d.y0));
     }

     
     
 })
</script>
